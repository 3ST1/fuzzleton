import {
  ArcRotateCamera,
  Color3,
  Engine,
  HighlightLayer,
  Mesh,
  MeshBuilder,
  PointerEventTypes,
  PointLight,
  Scene,
  StandardMaterial,
  Vector3,
  LinesMesh,
  KeyboardEventTypes,
  KeyboardInfo,
  Matrix,
  SceneLoader, // Add this import for loading GLTF models
  AssetContainer, // Add this import for handling loaded assets
  AbstractMesh,
  AssetsManager,
  HemisphericLight,
  TransformNode, // Add this import for handling loaded meshes
} from "@babylonjs/core";
import "@babylonjs/loaders/glTF"; // Import GLTF loader

import {
  AdvancedDynamicTexture,
  Button,
  Container,
  Control,
  Image,
  Rectangle,
  StackPanel,
  TextBlock,
  Checkbox, // Add this import for the grid toggle
  ScrollViewer, // Add this import for scrollable panel
} from "@babylonjs/gui";

class LevelCreator {
  private canvas!: HTMLCanvasElement;
  private engine!: Engine;
  private lvlCreatorScene!: Scene;
  private backToMenu!: () => void;
  private lvlCreatorCamera!: ArcRotateCamera;
  private editorUI!: AdvancedDynamicTexture;
  private ground!: Mesh;
  private materials: { [key: string]: StandardMaterial } = {};
  private isDragging: boolean = false;
  private currentDragMeshType: string = "";
  private previewMesh: Mesh | null = null;
  private placedMeshes: Mesh[] = []; // Track placed meshes
  private notificationText: TextBlock | null = null;
  private highlightLayer: HighlightLayer | null = null; // For highlighting selected objects
  private selectedMesh: Mesh | AbstractMesh | TransformNode | null = null; // Currently selected mesh
  private deleteButton: Button | null = null; // Button to delete selected mesh
  private meshControlsTexture: AdvancedDynamicTexture | null = null; // For mesh controls
  private snapToGrid: boolean = false; // Add this property for grid snapping toggle
  private gridSize: number = 10; // Grid cell size
  private gridMesh: LinesMesh | null = null; // Grid visual
  private snapToggleBtn: Checkbox | null = null; // Grid toggle button
  private upButton: Button | null = null; // Button to move mesh up
  private downButton: Button | null = null; // Button to move mesh down
  private leftButton: Button | null = null; // Button to move mesh left (-X)
  private rightButton: Button | null = null; // Button to move mesh right (+X)
  private forwardButton: Button | null = null; // Button to move mesh forward (-Z)
  private backwardButton: Button | null = null; // Button to move mesh backward (+Z)
  private yAxisStep: number = 5; // Step size for Y-axis movement
  private xzAxisStep: number = 5; // Step size for X and Z axis movement
  private objectControlsPanel: Rectangle | null = null; // Panel for object controls
  private objectControlsVisible: boolean = false;

  // New properties for model loading and management
  private modelAssets: { [key: string]: AssetContainer } = {}; // Store loaded models
  private modelFiles: string[] = [
    "arrow_teamBlue.gltf.glb",
    "arrow_teamRed.gltf.glb",
    "arrow_teamYellow.gltf.glb",
    "ball.gltf.glb",
    "ball_teamBlue.gltf.glb",
    "ball_teamRed.gltf.glb",
    "ball_teamYellow.gltf.glb",
    "barrierFloor.gltf.glb",
    "barrierLadder.gltf.glb",
  ];
  private modelsLoaded: boolean = false;
  private modelSidebar: Rectangle | null = null;
  assetsAvailable: any;

  constructor(canvas, engine, backToMenu) {
    this.engine = engine;
    this.canvas = canvas;
    this.backToMenu = backToMenu;

    this.init();
    this.initializeAssetsManager(this.lvlCreatorScene);
    this.loadModels();

    // Update the onFinish callback to properly check if models are loaded
    this.assetsManager.onFinish = () => {
      console.log(
        "All assets loaded, available models:",
        Object.keys(this.modelAssets)
      );
      this.modelsLoaded = true;
      this.levelCreatorUI();
      this.createModelSidebar();
    };

    this.assetsManager.load();
  }

  // Load all models from the file list
  loadModels(): void {
    this.modelFiles.forEach((filename) => {
      const modelId = this.getModelIdFromFilename(filename);
      this.loadAsset("/kaykit/", filename, modelId);
    });
  }

  getModelIdFromFilename(filename: string): string {
    return filename.replace(".gltf", "").replace(".glb", "");
  }

  // Example of properly structured material definitions with unique names
  init() {
    const scene = new Scene(this.engine);
    this.lvlCreatorScene = scene;

    // hide/show the Inspector
    window.addEventListener("keydown", (ev) => {
      // 'I' or 'i' to show/hide inspector
      if (ev.key === "i" || ev.key === "I") {
        if (this.lvlCreatorScene?.debugLayer.isVisible()) {
          this.lvlCreatorScene.debugLayer.hide();
        } else {
          this.lvlCreatorScene?.debugLayer.show();
        }
      }
    });
    const camera = new ArcRotateCamera(
      "Camera",
      0,
      0,
      10,
      new Vector3(0, 0, 0),
      scene
    );
    this.lvlCreatorCamera = camera;
    camera.setPosition(new Vector3(20, 200, 400));
    camera.attachControl(this.canvas, true);

    camera.upperBetaLimit = (Math.PI / 2) * 0.99;

    // Light
    // var light = new PointLight("omni", new Vector3(50, 200, 0), scene);
    var ligh = new HemisphericLight("light1", new Vector3(0, 1, 0), scene);

    //Materials
    var groundMaterial = new StandardMaterial("groundMaterial", scene);
    groundMaterial.diffuseColor = new Color3(0.9, 1, 1);

    var redMat = new StandardMaterial("redMaterial", scene);
    redMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
    redMat.specularColor = new Color3(0.4, 0.4, 0.4);
    redMat.emissiveColor = Color3.Red();

    var greenMat = new StandardMaterial("greenMaterial", scene);
    greenMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
    greenMat.specularColor = new Color3(0.4, 0.4, 0.4);
    greenMat.emissiveColor = Color3.Green();

    var blueMat = new StandardMaterial("blueMaterial", scene);
    blueMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
    blueMat.specularColor = new Color3(0.4, 0.4, 0.4);
    blueMat.emissiveColor = Color3.Blue();

    var purpleMat = new StandardMaterial("purpleMaterial", scene);
    purpleMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
    purpleMat.specularColor = new Color3(0.4, 0.4, 0.4);
    purpleMat.emissiveColor = Color3.Purple();

    // Store materials for reuse
    this.materials = {
      red: redMat,
      green: greenMat,
      blue: blueMat,
      purple: purpleMat,
      ground: groundMaterial,
    };

    /*************************************Meshes****************************************/
    // Ground
    var ground = MeshBuilder.CreateGround(
      "ground",
      { width: 1000, height: 1000 },
      this.lvlCreatorScene
    );
    ground.material = groundMaterial;
    ground.position.y = 0;
    this.ground = ground;

    // Create highlight layer for selection
    this.highlightLayer = new HighlightLayer("highlightLayer", scene);

    // Create grid mesh initially hidden
    this.createGridMesh();

    var startingPoint;
    var currentMesh;

    var getGroundPosition = () => {
      var pickinfo = this.lvlCreatorScene.pick(
        this.lvlCreatorScene.pointerX,
        this.lvlCreatorScene.pointerY,
        function (mesh) {
          return mesh == ground;
        }
      );
      if (pickinfo.hit) {
        return pickinfo.pickedPoint;
      }

      return null;
    };

    var pointerDown = (mesh) => {
      // Only allow interaction with meshes that are not ground or grid
      if (mesh === this.ground || (this.gridMesh && mesh === this.gridMesh)) {
        // Deselect when clicking on ground or grid
        this.deselectMesh();
        return; // Exit early to prevent further processing
      }

      // Find the topmost parent that is not the scene
      let rootMesh = mesh;
      while (rootMesh.parent && rootMesh.parent !== this.lvlCreatorScene) {
        if (
          rootMesh.parent instanceof AbstractMesh ||
          rootMesh.parent instanceof TransformNode
        ) {
          rootMesh = rootMesh.parent as Mesh;
        } else {
          break;
        }
      }

      currentMesh = rootMesh; // Set the root mesh as the current mesh
      startingPoint = getGroundPosition();

      // Handle selection when clicking on a mesh
      if (rootMesh !== this.previewMesh) {
        this.selectMesh(rootMesh as Mesh);
      }

      if (startingPoint) {
        // we need to disconnect camera from canvas
        setTimeout(() => {
          this.lvlCreatorCamera.detachControl();
        }, 0);
      }
    };

    var pointerUp = () => {
      if (startingPoint) {
        this.lvlCreatorCamera.attachControl(this.canvas, true);
        startingPoint = null;
        this.isDragging = false;
        currentMesh = null;

        if (this.previewMesh) {
          console.log("disposing preview mesh :", this.previewMesh.name);
          // create new mesh at the picked position then dispose preview mesh
          const newMesh = this.createMeshAtPosition(
            this.currentDragMeshType,
            this.previewMesh.position
          );

          this.previewMesh.dispose();
          this.previewMesh = null;
        }
        return;
      }
    };

    var pointerMove = () => {
      if (!startingPoint) {
        return;
      }
      var current = getGroundPosition();
      if (!current) {
        return;
      }

      // Calculate difference
      var diff = current.subtract(startingPoint);

      // Apply grid snapping if enabled
      if (this.snapToGrid && currentMesh && currentMesh !== this.ground) {
        // Instead of adding diff then snapping (which can cause lag),
        // directly calculate the new snapped position
        const newX =
          Math.round((currentMesh.position.x + diff.x) / this.gridSize) *
          this.gridSize;
        const newZ =
          Math.round((currentMesh.position.z + diff.z) / this.gridSize) *
          this.gridSize;

        // Directly set the position instead of calculating intermediate positions
        currentMesh.position.x = newX;
        currentMesh.position.z = newZ;
      } else {
        // Normal movement if snapping is disabled
        currentMesh.position.addInPlace(diff);
      }

      // Update starting point regardless of snapping
      startingPoint = current;
    };

    scene.onPointerObservable.add((pointerInfo) => {
      switch (pointerInfo.type) {
        case PointerEventTypes.POINTERDOWN:
          if (
            pointerInfo?.pickInfo &&
            pointerInfo.pickInfo.hit &&
            pointerInfo.pickInfo.pickedMesh !== this.ground &&
            pointerInfo.pickInfo.pickedMesh !== this.gridMesh
          ) {
            console.log(
              "Pointer down on mesh:",
              pointerInfo.pickInfo.pickedMesh
            );
            pointerDown(pointerInfo.pickInfo.pickedMesh);
          } else if (
            pointerInfo?.pickInfo &&
            (pointerInfo.pickInfo.pickedMesh === this.ground ||
              pointerInfo.pickInfo.pickedMesh === this.gridMesh)
          ) {
            // Deselect when clicking on ground or grid
            this.deselectMesh();
            // Still pass to pointerDown for camera controls
            pointerDown(pointerInfo.pickInfo.pickedMesh);
          }
          break;
        case PointerEventTypes.POINTERUP:
          pointerUp();
          break;
        case PointerEventTypes.POINTERMOVE:
          //   console.log("Pointer move");
          pointerMove();
          // Update preview mesh position if dragging
          if (this.isDragging && this.previewMesh) {
            console.log("dragging preview mesh :", this.previewMesh.name);
            const groundPos = getGroundPosition();
            if (groundPos) {
              if (this.snapToGrid) {
                // Apply grid snapping to preview mesh
                const snappedX =
                  Math.round(groundPos.x / this.gridSize) * this.gridSize;
                const snappedZ =
                  Math.round(groundPos.z / this.gridSize) * this.gridSize;
                this.previewMesh.position = new Vector3(snappedX, 10, snappedZ);
              } else {
                // Normal positioning
                this.previewMesh.position = new Vector3(
                  groundPos.x,
                  10,
                  groundPos.z
                );
              }
            }
          }
          break;
      }
    });

    // Add keyboard events for all axis movement
    this.lvlCreatorScene.onKeyboardObservable.add((kbInfo) => {
      if (kbInfo.type === KeyboardEventTypes.KEYDOWN && this.selectedMesh) {
        switch (kbInfo.event.key) {
          case "ArrowUp":
            this.moveMeshUp();
            break;
          case "ArrowDown":
            this.moveMeshDown();
            break;
          case "ArrowLeft":
            this.moveMeshLeft();
            break;
          case "ArrowRight":
            this.moveMeshRight();
            break;
          case "w": // Forward (negative Z)
            this.moveMeshForward();
            break;
          case "s": // Backward (positive Z)
            this.moveMeshBackward();
            break;
        }
      }
    });

    return scene;
  }

  // Method to select a mesh and highlight it
  // Method to select a mesh and highlight it
  selectMesh(mesh: AbstractMesh | TransformNode) {
    // Don't select ground or grid meshes
    if (mesh === this.ground || mesh === this.gridMesh) {
      return;
    }

    // If there's already a selected mesh, deselect it first
    if (this.selectedMesh && this.selectedMesh !== mesh) {
      this.deselectMesh();
    }

    // Set as selected mesh
    this.selectedMesh = mesh;

    // Add highlight to the selected mesh or its children if it's not a mesh
    if (this.highlightLayer && mesh) {
      if (mesh instanceof AbstractMesh) {
        this.highlightLayer.addMesh(mesh as Mesh, Color3.Yellow());
      }
      // If it's a TransformNode, highlight all its mesh children
      else if (mesh instanceof TransformNode) {
        const childMeshes = mesh.getChildMeshes();
        childMeshes.forEach((childMesh) => {
          this.highlightLayer?.addMesh(childMesh as Mesh, Color3.Yellow());
        });
      }

      console.log(`Selected object: ${mesh.name}`);

      // Create UI controls for the selected mesh
      this.createObjectControls();
    }
  }

  // Create UI controls for the selected object instead of 3D buttons
  createObjectControls() {
    // Remove existing panel if there is one
    if (this.objectControlsPanel) {
      this.objectControlsPanel.dispose();
      this.objectControlsPanel = null;
    }

    // Create controls panel - reduced height to fit better on screen
    const controlsPanel = new Rectangle("objectControlsPanel");
    controlsPanel.width = "220px";
    controlsPanel.height = "550px"; // Reduced from 600px to 500px for better fit
    controlsPanel.thickness = 2;
    controlsPanel.color = "white";
    controlsPanel.background = "rgba(50, 50, 50, 0.8)";
    controlsPanel.cornerRadius = 10;
    controlsPanel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    controlsPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    controlsPanel.top = "0px";
    controlsPanel.left = "20px";
    this.editorUI.addControl(controlsPanel);
    this.objectControlsPanel = controlsPanel;

    // Create a stack panel for organizing the buttons
    const stackPanel = new StackPanel("controlsStack");
    stackPanel.width = "100%";
    stackPanel.height = "100%"; // Make sure it takes full height of parent
    controlsPanel.addControl(stackPanel);

    // Add title
    const titleBlock = new TextBlock("controlsTitle", "Object Controls");
    titleBlock.color = "white";
    titleBlock.fontSize = 18;
    titleBlock.fontWeight = "bold";
    titleBlock.height = "30px";
    titleBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    titleBlock.paddingBottom = "5px"; // Reduced padding
    stackPanel.addControl(titleBlock);

    // Current position display
    const positionText = new TextBlock("positionText", "");
    positionText.color = "white";
    positionText.fontSize = 12;
    positionText.height = "30px"; // Reduced height
    positionText.paddingBottom = "5px"; // Reduced padding
    positionText.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    stackPanel.addControl(positionText);
    const rotaText = new TextBlock("rotationText", "");
    rotaText.color = "white";
    rotaText.fontSize = 12;
    rotaText.height = "30px"; // Reduced height
    rotaText.paddingBottom = "5px"; // Reduced padding
    rotaText.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    stackPanel.addControl(rotaText);

    // Update position info
    const updatePositionText = () => {
      if (this.selectedMesh) {
        const pos = this.selectedMesh.position;
        const rot = this.selectedMesh.rotation;

        // Convert rotation from radians to degrees for display
        const rotDegrees = {
          x: ((rot.x * 180) / Math.PI).toFixed(1),
          y: ((rot.y * 180) / Math.PI).toFixed(1),
          z: ((rot.z * 180) / Math.PI).toFixed(1),
        };

        positionText.text = `Position: X:${pos.x.toFixed(1)}, Y:${pos.y.toFixed(
          1
        )}, Z:${pos.z.toFixed(1)}`;
        rotaText.text = `Rotation: X:${rotDegrees.x}°, Y:${rotDegrees.y}°, Z:${rotDegrees.z}°`;
      }
    };
    updatePositionText();

    // Create direction control buttons with more spacing
    const directionControls = new Rectangle("directionControls");
    directionControls.height = "200px"; // Reduced from 250px
    directionControls.thickness = 0;
    directionControls.background = "transparent";
    stackPanel.addControl(directionControls);

    // X-Axis controls (Left/Right)
    const xAxisLabel = new TextBlock("xAxisLabel", "X-Axis (Left/Right)");
    xAxisLabel.color = "white";
    xAxisLabel.fontSize = 14;
    xAxisLabel.height = "20px";
    xAxisLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    directionControls.addControl(xAxisLabel);
    xAxisLabel.top = "-75px"; // Adjusted spacing

    const xControlsPanel = new StackPanel("xControlsPanel");
    xControlsPanel.isVertical = false;
    xControlsPanel.height = "40px";
    directionControls.addControl(xControlsPanel);
    xControlsPanel.top = "-45px"; // Adjusted spacing

    const leftBtn = Button.CreateSimpleButton("leftBtn", "←");
    leftBtn.width = "40px";
    leftBtn.height = "40px";
    leftBtn.color = "white";
    leftBtn.background = "green";
    leftBtn.onPointerClickObservable.add(() => this.moveMeshLeft());
    xControlsPanel.addControl(leftBtn);

    const rightBtn = Button.CreateSimpleButton("rightBtn", "→");
    rightBtn.width = "40px";
    rightBtn.height = "40px";
    rightBtn.color = "white";
    rightBtn.background = "green";
    rightBtn.onPointerClickObservable.add(() => this.moveMeshRight());
    xControlsPanel.addControl(rightBtn);

    // Y-Axis controls (Up/Down)
    const yAxisLabel = new TextBlock("yAxisLabel", "Y-Axis (Up/Down)");
    yAxisLabel.color = "white";
    yAxisLabel.fontSize = 14;
    yAxisLabel.height = "20px";
    yAxisLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    directionControls.addControl(yAxisLabel);
    yAxisLabel.top = "-5px"; // Adjusted spacing

    const yControlsPanel = new StackPanel("yControlsPanel");
    yControlsPanel.isVertical = false;
    yControlsPanel.height = "40px";
    directionControls.addControl(yControlsPanel);
    yControlsPanel.top = "20px"; // Same spacing

    const upBtn = Button.CreateSimpleButton("upBtn", "↑");
    upBtn.width = "40px";
    upBtn.height = "40px";
    upBtn.color = "white";
    upBtn.background = "blue";
    upBtn.onPointerClickObservable.add(() => this.moveMeshUp());
    yControlsPanel.addControl(upBtn);

    const downBtn = Button.CreateSimpleButton("downBtn", "↓");
    downBtn.width = "40px";
    downBtn.height = "40px";
    downBtn.color = "white";
    downBtn.background = "blue";
    downBtn.onPointerClickObservable.add(() => this.moveMeshDown());
    yControlsPanel.addControl(downBtn);

    // Z-Axis controls (Forward/Backward)
    const zAxisLabel = new TextBlock("zAxisLabel", "Z-Axis (Forward/Backward)");
    zAxisLabel.color = "white";
    zAxisLabel.fontSize = 14;
    zAxisLabel.height = "20px";
    zAxisLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    directionControls.addControl(zAxisLabel);
    zAxisLabel.top = "65px"; // Adjusted spacing

    const zControlsPanel = new StackPanel("zControlsPanel");
    zControlsPanel.isVertical = false;
    zControlsPanel.height = "40px";
    directionControls.addControl(zControlsPanel);
    zControlsPanel.top = "90px"; // Adjusted spacing

    const forwardBtn = Button.CreateSimpleButton("forwardBtn", "F");
    forwardBtn.width = "40px";
    forwardBtn.height = "40px";
    forwardBtn.color = "white";
    forwardBtn.background = "purple";
    forwardBtn.onPointerClickObservable.add(() => this.moveMeshForward());
    zControlsPanel.addControl(forwardBtn);

    const backwardBtn = Button.CreateSimpleButton("backwardBtn", "B");
    backwardBtn.width = "40px";
    backwardBtn.height = "40px";
    backwardBtn.color = "white";
    backwardBtn.background = "purple";
    backwardBtn.onPointerClickObservable.add(() => this.moveMeshBackward());
    zControlsPanel.addControl(backwardBtn);

    //////////////////////////////////////////////
    // Add rotation controls with reduced spacing
    const rotationLabel = new TextBlock("rotationLabel", "Rotation");
    rotationLabel.color = "white";
    rotationLabel.fontSize = 14;
    rotationLabel.height = "20px";
    rotationLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    stackPanel.addControl(rotationLabel);
    rotationLabel.paddingTop = "10px"; // Added padding instead of absolute positioning

    const rotationPanel = new StackPanel("rotationPanel");
    rotationPanel.isVertical = true;
    rotationPanel.height = "125px"; // Reduced from 130px
    rotationPanel.paddingTop = "5px";
    stackPanel.addControl(rotationPanel);

    // X-axis rotation (around X)
    const xRotationPanel = new StackPanel("xRotationPanel");
    xRotationPanel.isVertical = false;
    xRotationPanel.height = "40px";
    rotationPanel.addControl(xRotationPanel);

    const xRotLabel = new TextBlock("xRotLabel", "X:");
    xRotLabel.width = "20px";
    xRotLabel.color = "white";
    xRotLabel.fontSize = 12;
    xRotationPanel.addControl(xRotLabel);

    const rotateXLeftBtn = Button.CreateSimpleButton("rotateXLeftBtn", "⟲");
    rotateXLeftBtn.width = "40px";
    rotateXLeftBtn.height = "40px";
    rotateXLeftBtn.color = "white";
    rotateXLeftBtn.background = "darkred";
    rotateXLeftBtn.onPointerClickObservable.add(() => this.rotateMeshX(-15));
    xRotationPanel.addControl(rotateXLeftBtn);

    const rotateXRightBtn = Button.CreateSimpleButton("rotateXRightBtn", "⟳");
    rotateXRightBtn.width = "40px";
    rotateXRightBtn.height = "40px";
    rotateXRightBtn.color = "white";
    rotateXRightBtn.background = "darkred";
    rotateXRightBtn.onPointerClickObservable.add(() => this.rotateMeshX(15));
    xRotationPanel.addControl(rotateXRightBtn);

    // Y-axis rotation (around Y)
    const yRotationPanel = new StackPanel("yRotationPanel");
    yRotationPanel.isVertical = false;
    yRotationPanel.height = "40px";
    rotationPanel.addControl(yRotationPanel);

    const yRotLabel = new TextBlock("yRotLabel", "Y:");
    yRotLabel.width = "20px";
    yRotLabel.color = "white";
    yRotLabel.fontSize = 12;
    yRotationPanel.addControl(yRotLabel);

    const rotateYLeftBtn = Button.CreateSimpleButton("rotateYLeftBtn", "⟲");
    rotateYLeftBtn.width = "40px";
    rotateYLeftBtn.height = "40px";
    rotateYLeftBtn.color = "white";
    rotateYLeftBtn.background = "darkgreen";
    rotateYLeftBtn.onPointerClickObservable.add(() => this.rotateMeshY(-15));
    yRotationPanel.addControl(rotateYLeftBtn);

    const rotateYRightBtn = Button.CreateSimpleButton("rotateYRightBtn", "⟳");
    rotateYRightBtn.width = "40px";
    rotateYRightBtn.height = "40px";
    rotateYRightBtn.color = "white";
    rotateYRightBtn.background = "darkgreen";
    rotateYRightBtn.onPointerClickObservable.add(() => this.rotateMeshY(15));
    yRotationPanel.addControl(rotateYRightBtn);

    // Z-axis rotation (around Z)
    const zRotationPanel = new StackPanel("zRotationPanel");
    zRotationPanel.isVertical = false;
    zRotationPanel.height = "40px";
    rotationPanel.addControl(zRotationPanel);

    const zRotLabel = new TextBlock("zRotLabel", "Z:");
    zRotLabel.width = "20px";
    zRotLabel.color = "white";
    zRotLabel.fontSize = 12;
    zRotationPanel.addControl(zRotLabel);

    const rotateZLeftBtn = Button.CreateSimpleButton("rotateZLeftBtn", "⟲");
    rotateZLeftBtn.width = "40px";
    rotateZLeftBtn.height = "40px";
    rotateZLeftBtn.color = "white";
    rotateZLeftBtn.background = "darkblue";
    rotateZLeftBtn.onPointerClickObservable.add(() => this.rotateMeshZ(-15));
    zRotationPanel.addControl(rotateZLeftBtn);

    const rotateZRightBtn = Button.CreateSimpleButton("rotateZRightBtn", "⟳");
    rotateZRightBtn.width = "40px";
    rotateZRightBtn.height = "40px";
    rotateZRightBtn.color = "white";
    rotateZRightBtn.background = "darkblue";
    rotateZRightBtn.onPointerClickObservable.add(() => this.rotateMeshZ(15));
    zRotationPanel.addControl(rotateZRightBtn);

    // Scaling controls
    const scalingLabel = new TextBlock("scalingLabel", "Scale");
    scalingLabel.color = "white";
    scalingLabel.fontSize = 14;
    scalingLabel.height = "20px";
    scalingLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    // directionControls.addControl(scalingLabel);
    scalingLabel.top = "300px"; // Position below rotation controls

    const scalingPanel = new StackPanel("scalingPanel");
    scalingPanel.isVertical = false;
    scalingPanel.height = "40px";
    // directionControls.addControl(scalingPanel);
    scalingPanel.top = "370px";

    const scaleDownBtn = Button.CreateSimpleButton("scaleDownBtn", "-");
    scaleDownBtn.width = "40px";
    scaleDownBtn.height = "40px";
    scaleDownBtn.color = "white";
    scaleDownBtn.background = "purple";
    scaleDownBtn.onPointerClickObservable.add(() => this.scaleMesh(0.9));
    scalingPanel.addControl(scaleDownBtn);

    const scaleUpBtn = Button.CreateSimpleButton("scaleUpBtn", "+");
    scaleUpBtn.width = "40px";
    scaleUpBtn.height = "40px";
    scaleUpBtn.color = "white";
    scaleUpBtn.background = "purple";
    scaleUpBtn.onPointerClickObservable.add(() => this.scaleMesh(1.1));
    scalingPanel.addControl(scaleUpBtn);
    ////////////////////////////////////////
    // Add extra spacing between Z controls and delete button
    const spacerBetweenControls = new Rectangle("spacerBetweenControls");
    spacerBetweenControls.height = "10px";
    spacerBetweenControls.alpha = 0; // Make it invisible

    stackPanel.addControl(scalingLabel);

    stackPanel.addControl(scalingPanel);
    stackPanel.addControl(spacerBetweenControls);

    // Delete button at bottom with added spacing and fixed functionality
    const deleteBtn = Button.CreateSimpleButton("deleteBtn", "Delete Object");
    deleteBtn.width = "150px";
    deleteBtn.height = "35px";
    deleteBtn.color = "white";
    deleteBtn.background = "red";
    deleteBtn.cornerRadius = 5;
    deleteBtn.fontSize = 16;

    // Fix delete functionality
    deleteBtn.onPointerClickObservable.add(() => {
      if (this.selectedMesh) {
        // Store reference to avoid null issue during delete process
        const meshToDelete = this.selectedMesh;
        // First hide controls to avoid reference errors
        this.hideObjectControls();
        // Then delete the mesh
        this.deleteMesh(meshToDelete as Mesh);
      }
    });

    // Add to stack panel with padding
    stackPanel.addControl(deleteBtn);

    // Add bottom padding after delete button
    const bottomSpacer = new Rectangle("bottomSpacer");
    bottomSpacer.height = "15px";
    bottomSpacer.alpha = 0;
    stackPanel.addControl(bottomSpacer);

    // Register an observer to update position text
    this.lvlCreatorScene.registerBeforeRender(() => {
      if (this.selectedMesh && !this.selectedMesh.isDisposed()) {
        updatePositionText();
      } else if (this.objectControlsPanel) {
        // Hide the panel if the mesh is no longer selected
        this.hideObjectControls();
      }
    });

    this.objectControlsVisible = true;
  }

  // Hide object controls when deselecting
  hideObjectControls() {
    if (this.objectControlsPanel) {
      this.objectControlsPanel.dispose();
      this.objectControlsPanel = null;
      this.objectControlsVisible = false;
    }
  }

  // Method to deselect current mesh
  // Method to deselect current mesh
  deselectMesh() {
    if (this.selectedMesh && this.highlightLayer) {
      if (this.selectedMesh instanceof AbstractMesh) {
        this.highlightLayer.removeMesh(this.selectedMesh as Mesh);
      }
      // If it's a TransformNode, remove highlight from all its mesh children
      else if (this.selectedMesh instanceof TransformNode) {
        const childMeshes = this.selectedMesh.getChildMeshes();
        childMeshes.forEach((childMesh) => {
          this.highlightLayer?.removeMesh(childMesh as Mesh);
        });
      }

      console.log(`Deselected object: ${this.selectedMesh.name}`);
      this.selectedMesh = null;

      // Hide object controls
      this.hideObjectControls();
    }
  }

  // Method to move selected mesh up along the Y axis
  moveMeshUp() {
    if (this.selectedMesh) {
      if (this.snapToGrid) {
        // Fix: Calculate the next grid position up instead of rounding which can cause no movement
        const currentGridPos = Math.floor(
          this.selectedMesh.position.y / this.gridSize
        );
        const nextGridPos = currentGridPos + 1; // Move up to the next grid position
        this.selectedMesh.position.y = nextGridPos * this.gridSize;
      } else {
        this.selectedMesh.position.y += this.yAxisStep;
      }
    }
  }

  // Method to move selected mesh down along the Y axis
  moveMeshDown() {
    if (this.selectedMesh) {
      if (this.snapToGrid) {
        // Fix: Calculate the next grid position down
        const currentGridPos = Math.ceil(
          this.selectedMesh.position.y / this.gridSize
        );
        const nextGridPos = currentGridPos - 1; // Move down to the previous grid position

        // Ensure we don't go below ground level
        this.selectedMesh.position.y = Math.max(0, nextGridPos * this.gridSize);
      } else {
        this.selectedMesh.position.y -= this.yAxisStep;

        // Prevent going below ground level
        if (this.selectedMesh.position.y < 0) {
          this.selectedMesh.position.y = 0;
        }
      }
    }
  }

  // Method to move selected mesh left along the X axis
  moveMeshLeft() {
    if (this.selectedMesh) {
      if (this.snapToGrid) {
        // Calculate the next grid position left
        const currentGridPos = Math.ceil(
          this.selectedMesh.position.x / this.gridSize
        );
        const nextGridPos = currentGridPos - 1;
        this.selectedMesh.position.x = nextGridPos * this.gridSize;
      } else {
        this.selectedMesh.position.x -= this.xzAxisStep;
      }
    }
  }

  // Method to move selected mesh right along the X axis
  moveMeshRight() {
    if (this.selectedMesh) {
      if (this.snapToGrid) {
        // Calculate the next grid position right
        const currentGridPos = Math.floor(
          this.selectedMesh.position.x / this.gridSize
        );
        const nextGridPos = currentGridPos + 1;
        this.selectedMesh.position.x = nextGridPos * this.gridSize;
      } else {
        this.selectedMesh.position.x += this.xzAxisStep;
      }
    }
  }

  // Method to move selected mesh forward along the Z axis (negative Z in BabylonJS)
  moveMeshForward() {
    if (this.selectedMesh) {
      if (this.snapToGrid) {
        // Calculate the next grid position forward
        const currentGridPos = Math.ceil(
          this.selectedMesh.position.z / this.gridSize
        );
        const nextGridPos = currentGridPos - 1;
        this.selectedMesh.position.z = nextGridPos * this.gridSize;
      } else {
        this.selectedMesh.position.z -= this.xzAxisStep;
      }
    }
  }

  // Method to move selected mesh backward along the Z axis (positive Z in BabylonJS)
  moveMeshBackward() {
    if (this.selectedMesh) {
      if (this.snapToGrid) {
        // Calculate the next grid position backward
        const currentGridPos = Math.floor(
          this.selectedMesh.position.z / this.gridSize
        );
        const nextGridPos = currentGridPos + 1;
        this.selectedMesh.position.z = nextGridPos * this.gridSize;
      } else {
        this.selectedMesh.position.z += this.xzAxisStep;
      }
    }
  }

  // Methods for rotating meshes around different axes
  rotateMeshX(degrees: number) {
    if (this.selectedMesh) {
      const radians = (degrees * Math.PI) / 180;
      this.selectedMesh.rotate(new Vector3(1, 0, 0), radians);
    }
  }

  rotateMeshY(degrees: number) {
    if (this.selectedMesh) {
      const radians = (degrees * Math.PI) / 180;
      this.selectedMesh.rotate(new Vector3(0, 1, 0), radians);
    }
  }

  rotateMeshZ(degrees: number) {
    if (this.selectedMesh) {
      const radians = (degrees * Math.PI) / 180;
      this.selectedMesh.rotate(new Vector3(0, 0, 1), radians);
    }
  }

  // Method to scale the selected mesh
  scaleMesh(factor: number) {
    if (this.selectedMesh) {
      // Apply scaling uniformly to all dimensions
      this.selectedMesh.scaling.scaleInPlace(factor);
    }
  }

  createPreviewMesh(meshType: string) {
    this.deselectMesh();
    // Remove existing preview mesh if any
    if (this.previewMesh) {
      this.previewMesh.dispose();
      this.previewMesh = null;
    }

    // Create a new preview mesh based on the type
    switch (meshType) {
      case "sphere":
        this.previewMesh = MeshBuilder.CreateSphere(
          "preview-sphere",
          { diameter: 20 },
          this.lvlCreatorScene
        );
        this.previewMesh.material = this.materials.red;
        break;
      case "box-green":
        this.previewMesh = MeshBuilder.CreateBox(
          "preview-box-green",
          { size: 20 },
          this.lvlCreatorScene
        );
        this.previewMesh.material = this.materials.green;
        break;
      case "box-blue":
        this.previewMesh = MeshBuilder.CreateBox(
          "preview-box-blue",
          { size: 20 },
          this.lvlCreatorScene
        );
        this.previewMesh.material = this.materials.blue;
        break;
      case "torus":
        this.previewMesh = MeshBuilder.CreateTorus(
          "preview-torus",
          { diameter: 30, thickness: 10 },
          this.lvlCreatorScene
        );
        this.previewMesh.material = this.materials.purple;
        break;
    }

    if (this.previewMesh) {
      // Make the preview mesh semi-transparent
      const previewMaterial = this.previewMesh.material as StandardMaterial;
      if (previewMaterial) {
        previewMaterial.alpha = 0.3;
      }

      // Set initial position at a visible location
      this.previewMesh.position = new Vector3(0, 10, 0);
    }
  }

  createMeshAtPosition(meshType: string, position: Vector3): Mesh | undefined {
    // Check if this is one of our model meshes
    if (meshType.startsWith("model:")) {
      const modelId = meshType.replace("model:", "");
      return this.createModelAtPosition(modelId, position);
    }

    // Otherwise create one of the basic shapes
    let newMesh: Mesh;
    const timestamp = Date.now().toString();

    try {
      switch (meshType) {
        case "sphere":
          newMesh = MeshBuilder.CreateSphere(
            "placed-sphere-" + timestamp,
            { diameter: 20 },
            this.lvlCreatorScene
          );
          // Create a completely new material rather than clone
          const redMat = new StandardMaterial(
            "red-mat-" + timestamp,
            this.lvlCreatorScene
          );
          redMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
          redMat.specularColor = new Color3(0.4, 0.4, 0.4);
          redMat.emissiveColor = Color3.Red();
          newMesh.material = redMat;
          break;
        case "box-green":
          newMesh = MeshBuilder.CreateBox(
            "placed-green-" + timestamp,
            { size: 20 },
            this.lvlCreatorScene
          );
          // Create a completely new material rather than clone
          const greenMat = new StandardMaterial(
            "green-mat-" + timestamp,
            this.lvlCreatorScene
          );
          greenMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
          greenMat.specularColor = new Color3(0.4, 0.4, 0.4);
          greenMat.emissiveColor = Color3.Green();
          newMesh.material = greenMat;
          break;
        case "box-blue":
          newMesh = MeshBuilder.CreateBox(
            "placed-blue-" + timestamp,
            { size: 20 },
            this.lvlCreatorScene
          );
          // Create a completely new material rather than clone
          const blueMat = new StandardMaterial(
            "blue-mat-" + timestamp,
            this.lvlCreatorScene
          );
          blueMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
          blueMat.specularColor = new Color3(0.4, 0.4, 0.4);
          blueMat.emissiveColor = Color3.Blue();
          newMesh.material = blueMat;
          break;
        case "torus":
          newMesh = MeshBuilder.CreateTorus(
            "placed-torus-" + timestamp,
            { diameter: 30, thickness: 10 },
            this.lvlCreatorScene
          );
          // Create a completely new material rather than clone
          const purpleMat = new StandardMaterial(
            "purple-mat-" + timestamp,
            this.lvlCreatorScene
          );
          purpleMat.diffuseColor = new Color3(0.4, 0.4, 0.4);
          purpleMat.specularColor = new Color3(0.4, 0.4, 0.4);
          purpleMat.emissiveColor = Color3.Purple();
          newMesh.material = purpleMat;
          break;
        default:
          return undefined;
      }

      // Set position and make sure it's above ground
      // Apply snapping if enabled
      if (this.snapToGrid) {
        const snappedX = Math.round(position.x / this.gridSize) * this.gridSize;
        const snappedZ = Math.round(position.z / this.gridSize) * this.gridSize;
        const snappedY = Math.max(
          Math.round(position.y / this.gridSize) * this.gridSize,
          0
        );
        newMesh.position = new Vector3(snappedX, snappedY, snappedZ);
      } else {
        newMesh.position = new Vector3(
          position.x,
          Math.max(position.y, 0),
          position.z
        );
      }

      // Log for debugging
      console.log(
        `Created new mesh: ${newMesh.name} at position: ${position.x}, 10, ${position.z}`
      );
      console.log(`Total placed meshes: ${this.placedMeshes.length + 1}`);

      // Make sure the mesh isn't disposed
      newMesh.isVisible = true;

      // Add the new mesh to the placedMeshes array
      this.placedMeshes.push(newMesh);

      return newMesh;
    } catch (error) {
      console.error("Error creating mesh:", error);
      return undefined;
    }
  }

  // Create actual model at position
  createModelAtPosition(modelId: string, position: Vector3): Mesh | undefined {
    console.log(`Placing model ${modelId} at position ${position}`);

    // Check if the model is loaded
    const assetContainer = this.modelAssets[modelId];
    if (!assetContainer) {
      console.error(
        `Model ${modelId} not found in loaded assets. Available models: ${Object.keys(
          this.modelAssets
        ).join(", ")}`
      );
      return undefined;
    }

    try {
      // Create a unique name for this instance
      const timestamp = Date.now().toString();

      // Instantiate model
      const meshes = assetContainer.instantiateModelsToScene(
        (name) => `placed-${modelId}-${timestamp}-${name}`,
        false
      );

      if (!meshes || meshes.rootNodes.length === 0) {
        console.error(`Failed to instantiate model ${modelId}`);
        return undefined;
      }

      const rootMesh = meshes.rootNodes[0] as Mesh;

      // Apply snapping if enabled
      if (this.snapToGrid) {
        const snappedX = Math.round(position.x / this.gridSize) * this.gridSize;
        const snappedZ = Math.round(position.z / this.gridSize) * this.gridSize;
        const snappedY = Math.max(
          Math.round(position.y / this.gridSize) * this.gridSize,
          0
        );
        rootMesh.position = new Vector3(snappedX, snappedY, snappedZ);
      } else {
        rootMesh.position = new Vector3(
          position.x,
          Math.max(position.y, 0),
          position.z
        );
      }

      // Scale the model to a reasonable size
      const scaleFactor = 15 / rootMesh.getBoundingInfo().boundingSphere.radius;
      rootMesh.scaling = new Vector3(scaleFactor, scaleFactor, scaleFactor);

      // Add the root mesh to the placedMeshes array for tracking
      this.placedMeshes.push(rootMesh);

      console.log(
        `Successfully placed model ${modelId} at position ${rootMesh.position}`
      );
      return rootMesh;
    } catch (error) {
      console.error(`Error creating model ${modelId} at position:`, error);
      return undefined;
    }
  }

  levelCreatorUI() {
    // Create UI with "Back to Menu" button
    const editorUI = AdvancedDynamicTexture.CreateFullscreenUI("editorUI");
    this.editorUI = editorUI;

    const backButton = Button.CreateSimpleButton("backButton", "Back to Menu");
    backButton.width = "150px";
    backButton.height = "40px";
    backButton.color = "white";
    backButton.background = "orange";
    backButton.cornerRadius = 5;
    backButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    backButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    backButton.left = "20px";
    backButton.top = "20px";

    backButton.onPointerClickObservable.add(() => {
      this.lvlCreatorScene.dispose();
      this.backToMenu();
    });

    editorUI.addControl(backButton);

    // Editor title
    const editorTitle = new TextBlock("editorTitle", "Level Creator");
    editorTitle.color = "white";
    editorTitle.fontSize = 36;
    editorTitle.height = "40px";
    editorTitle.fontWeight = "bold";
    editorTitle.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    editorTitle.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    editorTitle.top = "20px";
    editorUI.addControl(editorTitle);

    // // Add counter display for placed meshes
    // const meshCounter = new TextBlock("meshCounter", "Placed meshes: 0");
    // meshCounter.color = "white";
    // meshCounter.fontSize = 16;
    // meshCounter.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    // meshCounter.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    // meshCounter.left = "20px";
    // meshCounter.top = "70px"; // Position below back button
    // editorUI.addControl(meshCounter);

    // // Update counter every second
    // setInterval(() => {
    //   meshCounter.text = `Placed meshes: ${this.placedMeshes.length}`;
    // }, 1000);

    // Add keyboard controls instruction with expanded directions
    // const keyboardHelpText = new TextBlock(
    //   "keyboardHelp",
    //   "Arrow keys: Move selected object (↑↓←→)\nW/S: Move forward/backward"
    // );
    // keyboardHelpText.color = "white";
    // keyboardHelpText.fontSize = 14;
    // keyboardHelpText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    // keyboardHelpText.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    // keyboardHelpText.left = "20px";
    // keyboardHelpText.top = "-50px";
    // editorUI.addControl(keyboardHelpText);

    // Create primitive shape sidebar on the right
    this.createSidebar();

    // Grid toggle remains at bottom right
    this.createSnapToGridToggle();
  }

  // Modified original sidebar to be right-aligned and renamed to "Shapes"
  createSidebar() {
    // Create sidebar panel
    const sidebar = new Rectangle("shapesSidebar");
    sidebar.width = "250px";
    sidebar.height = "80%";
    sidebar.thickness = 2;
    sidebar.color = "white";
    sidebar.background = "rgba(50, 50, 50, 0.7)";
    sidebar.cornerRadius = 10;
    sidebar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT; // Keep on right
    sidebar.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    sidebar.paddingRight = "20px";
    this.editorUI.addControl(sidebar);

    // Create stack panel for mesh items
    const stackPanel = new StackPanel("shapesPanel");
    stackPanel.width = "100%";
    stackPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    sidebar.addControl(stackPanel);

    // Title for the sidebar - changed to "Basic Shapes"
    const sidebarTitle = new TextBlock("sidebarTitle", "Basic Shapes");
    sidebarTitle.color = "white";
    sidebarTitle.fontSize = 20;
    sidebarTitle.height = "40px";
    sidebarTitle.fontWeight = "bold";
    sidebarTitle.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    sidebarTitle.paddingTop = "10px";
    sidebarTitle.paddingBottom = "10px";
    stackPanel.addControl(sidebarTitle);

    // Add mesh items with spacing between them (unchanged)
    this.createMeshItem(stackPanel, "sphere", "Sphere", "red");
    stackPanel.addControl(this.createSpacing(10));
    this.createMeshItem(stackPanel, "box-green", "Green Box", "green");
    stackPanel.addControl(this.createSpacing(10));
    this.createMeshItem(stackPanel, "box-blue", "Blue Box", "blue");
    stackPanel.addControl(this.createSpacing(10));
    this.createMeshItem(stackPanel, "torus", "Purple Torus", "purple");
  }

  // Helper method to create spacing between items
  createSpacing(height: number): Rectangle {
    const spacing = new Rectangle("spacing");
    spacing.width = 1;
    spacing.height = `${height}px`;
    spacing.alpha = 0; // Make it invisible
    return spacing;
  }

  createMeshItem(
    parent: Container,
    meshType: string,
    label: string,
    color: string
  ) {
    // Container for the mesh item
    const itemContainer = new Rectangle(`${meshType}-container`);
    itemContainer.width = "220px";
    itemContainer.height = "60px";
    itemContainer.thickness = 1;
    itemContainer.color = "lightgray";
    itemContainer.background = "rgba(70, 70, 70, 0.9)";
    itemContainer.cornerRadius = 5;
    itemContainer.paddingBottom = "10px";
    itemContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    itemContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    itemContainer.isPointerBlocker = true;
    parent.addControl(itemContainer);

    // Label for the mesh
    const meshLabel = new TextBlock(`${meshType}-label`, label);
    meshLabel.color = "white";
    meshLabel.fontSize = 16;
    meshLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    meshLabel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    meshLabel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    meshLabel.top = "5px";
    itemContainer.addControl(meshLabel);

    // Preview shape
    const previewShape = new Rectangle(`${meshType}-preview`);
    previewShape.width = "30px";
    previewShape.height = "30px";
    previewShape.cornerRadius = meshType.includes("sphere")
      ? 15
      : meshType.includes("torus")
      ? 5
      : 0;
    previewShape.background = color;
    previewShape.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    previewShape.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    previewShape.top = "-10px";
    itemContainer.addControl(previewShape);

    // Make the item draggable
    itemContainer.onPointerDownObservable.add(() => {
      this.isDragging = true;
      this.currentDragMeshType = meshType;
      this.createPreviewMesh(meshType);
    });
  }

  createSnapToGridToggle() {
    // Container for the grid toggle
    const gridContainer = new Rectangle("gridToggleContainer");
    gridContainer.width = "180px";
    gridContainer.height = "40px";
    gridContainer.background = "rgba(50, 50, 50, 0.7)";
    gridContainer.cornerRadius = 5;
    gridContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;
    gridContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    gridContainer.top = "-20px";
    gridContainer.left = "-20px";
    this.editorUI.addControl(gridContainer);

    // Create checkbox
    this.snapToggleBtn = new Checkbox("snapToGridToggle");
    this.snapToggleBtn.width = "20px";
    this.snapToggleBtn.height = "20px";
    this.snapToggleBtn.color = "white";
    this.snapToggleBtn.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    this.snapToggleBtn.left = "10px";
    gridContainer.addControl(this.snapToggleBtn);

    // Add label for checkbox
    const toggleLabel = new TextBlock("gridToggleLabel", "Snap to Grid");
    toggleLabel.color = "white";
    toggleLabel.fontSize = 16;
    toggleLabel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    toggleLabel.left = "40px";
    gridContainer.addControl(toggleLabel);

    // Add event to toggle grid visibility and snapping
    this.snapToggleBtn.onIsCheckedChangedObservable.add((isChecked) => {
      this.toggleGrid(isChecked);
    });
  }

  // Create grid mesh for visualization
  createGridMesh() {
    if (this.gridMesh) {
      this.gridMesh.dispose();
    }

    // Size of the grid (should be large enough to cover your ground)
    const size = 1000;
    const gridLines: Vector3[][] = [];
    const step = this.gridSize;
    const halfSize = size / 2;

    // Create grid lines along X axis
    for (let i = -halfSize; i <= halfSize; i += step) {
      gridLines.push([
        new Vector3(i, 0.1, -halfSize),
        new Vector3(i, 0.1, halfSize),
      ]);
    }

    // Create grid lines along Z axis
    for (let i = -halfSize; i <= halfSize; i += step) {
      gridLines.push([
        new Vector3(-halfSize, 0.1, i),
        new Vector3(halfSize, 0.1, i),
      ]);
    }

    // Create the grid mesh
    this.gridMesh = MeshBuilder.CreateLineSystem(
      "gridMesh",
      { lines: gridLines },
      this.lvlCreatorScene
    );

    // Set grid material
    const gridMat = new StandardMaterial("gridMat", this.lvlCreatorScene);
    gridMat.emissiveColor = new Color3(0.5, 0.5, 0.5);
    gridMat.alpha = 0.5;
    this.gridMesh.material = gridMat;

    // Initially hidden
    this.gridMesh.isVisible = false;
  }

  // Toggle grid visibility and enhance performance when snapping is on
  toggleGrid(visible: boolean) {
    if (this.gridMesh) {
      this.gridMesh.isVisible = visible;
    }
    this.snapToGrid = visible;

    // When enabling grid snapping, snap all existing meshes to grid immediately
    if (visible) {
      this.placedMeshes.forEach((mesh) => {
        if (mesh && !mesh.isDisposed()) {
          mesh.position.x =
            Math.round(mesh.position.x / this.gridSize) * this.gridSize;
          mesh.position.z =
            Math.round(mesh.position.z / this.gridSize) * this.gridSize;
        }
      });
    }
  }

  // Create model sidebar with actual models
  createModelSidebar() {
    // Create model sidebar panel
    const sidebar = new Rectangle("modelSidebar");
    sidebar.width = "250px";
    sidebar.height = "80%";
    sidebar.thickness = 2;
    sidebar.color = "white";
    sidebar.background = "rgba(50, 50, 50, 0.7)";
    sidebar.cornerRadius = 10;
    sidebar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    sidebar.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    sidebar.paddingLeft = "20px";
    this.editorUI.addControl(sidebar);
    this.modelSidebar = sidebar;

    // Create scrollable panel for models
    const scrollViewer = new ScrollViewer("modelScroll");
    scrollViewer.width = "100%";
    scrollViewer.height = "95%";
    scrollViewer.barSize = 15;
    scrollViewer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    sidebar.addControl(scrollViewer);

    // Create stack panel for model items
    const stackPanel = new StackPanel("modelPanel");
    stackPanel.width = "100%";
    stackPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    scrollViewer.addControl(stackPanel);

    // Title for the sidebar
    const sidebarTitle = new TextBlock("modelSidebarTitle", "Available Models");
    sidebarTitle.color = "white";
    sidebarTitle.fontSize = 20;
    sidebarTitle.height = "40px";
    sidebarTitle.fontWeight = "bold";
    sidebarTitle.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    sidebarTitle.paddingTop = "10px";
    sidebarTitle.paddingBottom = "10px";
    stackPanel.addControl(sidebarTitle);

    // Add each model to the sidebar
    for (const filename of this.modelFiles) {
      const modelId = this.getModelIdFromFilename(filename);

      // Determine color based on model name
      let color = "gray";
      if (modelId.includes("Blue")) color = "blue";
      else if (modelId.includes("Red")) color = "red";
      else if (modelId.includes("Yellow")) color = "yellow";

      this.createModelItem(
        stackPanel,
        modelId,
        this.formatModelName(modelId),
        color
      );
      stackPanel.addControl(this.createSpacing(10));
    }
  }

  // Format model name for display
  formatModelName(modelId: string): string {
    // Convert camelCase to Title Case with spaces
    return modelId
      .replace(/([a-z])([A-Z])/g, "$1 $2") // Insert space between camelCase
      .replace(/_/g, " ") // Replace underscores with spaces
      .replace(/team/i, "Team ") // Add space after "team"
      .split(" ")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");
  }

  // Create an item in the model sidebar
  createModelItem(
    parent: Container,
    modelId: string,
    label: string,
    color: string
  ) {
    // Container for the model item
    const itemContainer = new Rectangle(`model-${modelId}-container`);
    itemContainer.width = "220px";
    itemContainer.height = "70px";
    itemContainer.thickness = 1;
    itemContainer.color = "lightgray";
    itemContainer.background = "rgba(70, 70, 70, 0.9)";
    itemContainer.cornerRadius = 5;
    itemContainer.paddingBottom = "10px";
    itemContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    itemContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    itemContainer.isPointerBlocker = true;
    parent.addControl(itemContainer);

    // Label for the model
    const modelLabel = new TextBlock(`model-${modelId}-label`, label);
    modelLabel.color = "white";
    modelLabel.fontSize = 14;
    modelLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    modelLabel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    modelLabel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    modelLabel.top = "5px";
    itemContainer.addControl(modelLabel);

    // Preview indicator (simple colored rectangle for now)
    const previewShape = new Rectangle(`model-${modelId}-preview`);
    previewShape.width = "40px";
    previewShape.height = "40px";
    previewShape.cornerRadius = 5;
    previewShape.background = color;
    previewShape.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    previewShape.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    previewShape.top = "-10px";
    itemContainer.addControl(previewShape);

    // Make the item draggable
    itemContainer.onPointerDownObservable.add(() => {
      this.isDragging = true;
      this.currentDragMeshType = `model:${modelId}`; // Prefix to indicate it's a model
      this.createModelPreview(modelId);
    });
  }

  // Create a preview of the model for dragging
  createModelPreview(modelId: string) {
    this.deselectMesh();

    // Remove existing preview mesh if any
    if (this.previewMesh) {
      this.previewMesh.dispose();
      this.previewMesh = null;
    }

    console.log(`Creating preview for model: ${modelId}`);
    console.log(
      `Available models: ${Object.keys(this.modelAssets).join(", ")}`
    );

    // Check if the model is loaded
    const assetContainer = this.modelAssets[modelId];
    if (!assetContainer) {
      console.error(`Model ${modelId} not found in loaded assets`);
      return;
    }

    try {
      // Create instance of the model for preview
      const result = assetContainer.instantiateModelsToScene(
        (name) => `preview-${name}`,
        false, // Don't add a root to the scene
        { doNotInstantiate: false }
      );

      if (result.rootNodes.length > 0) {
        this.previewMesh = result.rootNodes[0] as Mesh;

        // Apply semi-transparency
        result.meshes.forEach((mesh) => {
          if (mesh.material) {
            const material = mesh.material;
            material.alpha = 0.5;
            if (material instanceof StandardMaterial) {
              material.transparencyMode = 2; // ALPHABLEND
            }
          }
        });

        // Position the preview mesh at a visible height
        this.previewMesh.position = new Vector3(0, 10, 0);

        // Scale if needed
        const scaleFactor =
          15 / this.previewMesh.getBoundingInfo().boundingSphere.radius;
        this.previewMesh.scaling = new Vector3(
          scaleFactor,
          scaleFactor,
          scaleFactor
        );

        console.log(`Preview mesh created for ${modelId}`);
      } else {
        console.error(`No root nodes found in model ${modelId}`);
      }
    } catch (error) {
      console.error(`Error creating preview for model ${modelId}:`, error);
    }
  }

  // Method to delete a mesh - updated to handle model meshes with children
  deleteMesh(mesh: Mesh) {
    if (!mesh || mesh.isDisposed()) return;

    // Check if this is a root node of a model and dispose all children
    const isModelRoot =
      mesh.name.includes("placed-") && mesh.name.includes("-root");

    if (isModelRoot) {
      // If it's a model root, dispose all its children too
      const childrenToDispose = [...mesh.getChildMeshes()];
      childrenToDispose.forEach((child) => {
        if (this.highlightLayer) {
          this.highlightLayer.removeMesh(child as Mesh);
        }
        child.dispose();
      });
    }

    // Remove from placed meshes array
    const index = this.placedMeshes.findIndex((m) => m === mesh);
    if (index !== -1) {
      this.placedMeshes.splice(index, 1);
    }

    // Remove highlight if it exists
    if (this.highlightLayer) {
      this.highlightLayer.removeMesh(mesh);
    }

    // If this is the selected mesh, clear the reference
    if (mesh === this.selectedMesh) {
      this.selectedMesh = null;
    }

    // Dispose the mesh
    mesh.dispose();
    console.log(`Deleted mesh: ${mesh.name}`);
  }

  public render() {
    this.engine.runRenderLoop(() => {
      this.lvlCreatorScene.render();
    });
  }

  ////////////////////////
  private assetsManager!: AssetsManager;

  private initializeAssetsManager(scene: Scene): AssetsManager {
    console.log("Initializing assets manager...");
    this.assetsManager = new AssetsManager(scene);
    console.log("Assets manager initialized: ", this.assetsManager);
    this.assetsManager.onProgress = (
      remainingCount,
      totalCount,
      lastFinishedTask
    ) => {
      console.log(
        "Loading assets: ",
        remainingCount,
        " out of ",
        totalCount,
        " items still need to be loaded."
      );

      this.engine.loadingUIText =
        "Loading the scene... " +
        remainingCount +
        " out of " +
        totalCount +
        " items still need to be loaded.";
    };

    //put the text at the bottom of the screen
    this.engine.loadingScreen.loadingUIBackgroundColor = "orange";

    this.assetsManager.onFinish = (tasks) => {
      console.log("All assets loaded: ", tasks);
      // this.hideLoading();
    };

    return this.assetsManager;
  }

  // Completely replace the loadAsset method with this better implementation
  public loadAsset(rootPath, filename, id): void {
    console.log(`Loading asset: ${rootPath}${filename} with ID ${id}`);

    // Create task to load the model
    const meshTask = this.assetsManager.addMeshTask(
      `task-${id}`,
      "",
      rootPath,
      filename
    );

    // On success handler
    meshTask.onSuccess = (task) => {
      console.log(`Successfully loaded model: ${id}`);

      // Create a new asset container from the loaded task
      const container = new AssetContainer(this.lvlCreatorScene);

      // Add all loaded meshes to the container
      task.loadedMeshes.forEach((mesh) => {
        container.meshes.push(mesh);
      });

      // Add all loaded skeletons to the container
      task.loadedSkeletons.forEach((skeleton) => {
        container.skeletons.push(skeleton);
      });

      // Add all loaded animation groups to the container
      task.loadedAnimationGroups.forEach((animationGroup) => {
        container.animationGroups.push(animationGroup);
      });

      // Add all loaded particle systems to the container
      task.loadedParticleSystems.forEach((particleSystem) => {
        container.particleSystems.push(particleSystem);
      });

      // Add all loaded materials to the container
      const materials = [];
      task.loadedMeshes.forEach((mesh) => {
        if (mesh.material) {
          if (!materials.includes(mesh.material)) {
            materials.push(mesh.material);
            container.materials.push(mesh.material);
          }
        }
      });

      // Hide the original meshes (we'll instantiate them as needed)
      task.loadedMeshes.forEach((mesh) => {
        mesh.setEnabled(false);
      });

      // Store the container in our dictionary
      this.modelAssets[id] = container;
      console.log(`Asset ${id} loaded and stored in modelAssets`);
    };

    // On error handler
    meshTask.onError = (task, message, exception) => {
      console.error(`Error loading model ${id}: ${message}`);
    };
  }

  // Fix the createModelPreview method to properly handle models
  createModelPreview(modelId: string) {
    this.deselectMesh();

    // Remove existing preview mesh if any
    if (this.previewMesh) {
      this.previewMesh.dispose();
      this.previewMesh = null;
    }

    console.log(`Creating preview for model: ${modelId}`);
    console.log(
      `Available models: ${Object.keys(this.modelAssets).join(", ")}`
    );

    // Check if the model is loaded
    const assetContainer = this.modelAssets[modelId];
    if (!assetContainer) {
      console.error(`Model ${modelId} not found in loaded assets`);
      return;
    }

    try {
      // Create instance of the model for preview
      const result = assetContainer.instantiateModelsToScene(
        (name) => `preview-${name}`,
        false, // Don't add a root to the scene
        { doNotInstantiate: false }
      );

      if (result.rootNodes.length > 0) {
        this.previewMesh = result.rootNodes[0] as Mesh;

        // Apply semi-transparency
        result.meshes.forEach((mesh) => {
          if (mesh.material) {
            const material = mesh.material;
            material.alpha = 0.5;
            if (material instanceof StandardMaterial) {
              material.transparencyMode = 2; // ALPHABLEND
            }
          }
        });

        // Position the preview mesh at a visible height
        this.previewMesh.position = new Vector3(0, 10, 0);

        // Scale if needed
        const scaleFactor =
          15 / this.previewMesh.getBoundingInfo().boundingSphere.radius;
        this.previewMesh.scaling = new Vector3(
          scaleFactor,
          scaleFactor,
          scaleFactor
        );

        console.log(`Preview mesh created for ${modelId}`);
      } else {
        console.error(`No root nodes found in model ${modelId}`);
      }
    } catch (error) {
      console.error(`Error creating preview for model ${modelId}:`, error);
    }
  }

  // Also fix the createModelAtPosition method for the same reasons
  createModelAtPosition(modelId: string, position: Vector3): Mesh | undefined {
    console.log(`Placing model ${modelId} at position ${position}`);

    // Check if the model is loaded
    const assetContainer = this.modelAssets[modelId];
    if (!assetContainer) {
      console.error(
        `Model ${modelId} not found in loaded assets. Available models: ${Object.keys(
          this.modelAssets
        ).join(", ")}`
      );
      return undefined;
    }

    try {
      // Create a unique name for this instance
      const timestamp = Date.now().toString();

      // Instantiate model
      const result = assetContainer.instantiateModelsToScene(
        (name) => `placed-${modelId}-${timestamp}-${name}`,
        false,
        { doNotInstantiate: false }
      );

      if (!result || result.rootNodes.length === 0) {
        console.error(`Failed to instantiate model ${modelId}`);
        return undefined;
      }

      const rootMesh = result.rootNodes[0] as Mesh;

      // Make sure all meshes are visible
      result.meshes.forEach((mesh) => {
        mesh.isVisible = true;
      });

      // Apply snapping if enabled
      if (this.snapToGrid) {
        const snappedX = Math.round(position.x / this.gridSize) * this.gridSize;
        const snappedZ = Math.round(position.z / this.gridSize) * this.gridSize;
        const snappedY = Math.max(
          Math.round(position.y / this.gridSize) * this.gridSize,
          0
        );
        rootMesh.position = new Vector3(snappedX, snappedY, snappedZ);
      } else {
        rootMesh.position = new Vector3(
          position.x,
          Math.max(position.y, 0),
          position.z
        );
      }

      // Scale the model to a reasonable size
      const scaleFactor = 15 / rootMesh.getBoundingInfo().boundingSphere.radius;
      rootMesh.scaling = new Vector3(scaleFactor, scaleFactor, scaleFactor);

      // Add the root mesh to the placedMeshes array for tracking
      this.placedMeshes.push(rootMesh);

      console.log(
        `Successfully placed model ${modelId} at position ${rootMesh.position}`
      );
      return rootMesh;
    } catch (error) {
      console.error(`Error creating model ${modelId} at position:`, error);
      return undefined;
    }
  }
}

export const addItem = (
  assetsManager: AssetsManager,
  rootUrl: string,
  model: string,
  id: string,
  onSuccess: any = null,
  onError: any = null
) => {
  if (!rootUrl || !model) {
    console.error("No asset provided -> not adding it to the scene.");
    return false;
  }

  console.log(
    "Adding the following item to asset manager: ",
    id,
    rootUrl,
    model
  );

  const meshTask = assetsManager.addMeshTask(id, "", rootUrl, model);

  // Pass in custom function to call after asset loads
  meshTask.onSuccess = onSuccess;

  // On error, just get rid of any problematic meshes
  meshTask.onError = (task) => {
    if (task.loadedMeshes && task.loadedMeshes.length > 0) {
      task.loadedMeshes.forEach((mesh) => {
        mesh.dispose();
      });
    }
  };
  return meshTask;
};

export default LevelCreator;
