import {
  Scene,
  Mesh,
  Color3,
  Vector3,
  AbstractMesh,
  LinesMesh,
} from "@babylonjs/core";

import {
  AdvancedDynamicTexture,
  Button,
  Container,
  Control,
  Rectangle,
  StackPanel,
  TextBlock,
  Checkbox,
  ScrollViewer,
  InputText,
} from "@babylonjs/gui";

import { UIComponentsFactory } from "./UIComponentsFactory";
import { AssetManagerService } from "../AssetManagerService";

// export const DEFAULT_BUTTON_COLOR = "rgba(100, 100, 100, 0.8)";
export interface MeshItem {
  id: string;
  modelId?: string;
  type: string;
  label: string;
  color: string;
  imageUrl?: string;
}

export interface UIEvents {
  onGridToggle: (enabled: boolean) => void;
  onSaveScene: () => Promise<void>;
  onLoadScene: () => Promise<void>;
  onBackToMenu: () => void;
  onModelSelected: (modelId: string) => void;
  onTestLevel: () => Promise<void>;
}

export class LevelCreatorUI {
  public editorUI: AdvancedDynamicTexture;
  private loadingScreen!: Rectangle;
  private loadingText!: TextBlock;

  // UI properties
  private modelSidebar!: Rectangle;
  private saveLoadPanel: Rectangle | null = null;
  private snapToggleBtn: Checkbox | null = null;

  // Dependencies
  private scene: Scene;
  private ground: Mesh;
  private gridMesh: LinesMesh | null;
  private assetManager: AssetManagerService;
  private highlightLayer: any;

  // Event handlers
  private events: UIEvents;

  // State
  private sceneName: string = "MyLevel";

  constructor(
    scene: Scene,
    ground: Mesh,
    gridMesh: LinesMesh | null,
    assetManager: AssetManagerService,
    highlightLayer: any,
    events: UIEvents
  ) {
    this.scene = scene;
    this.ground = ground;
    this.gridMesh = gridMesh;
    this.assetManager = assetManager;
    this.highlightLayer = highlightLayer;
    this.events = events;

    // Create fullscreen UI
    this.editorUI = AdvancedDynamicTexture.CreateFullscreenUI(
      "editorUI",
      true,
      scene
    );

    // Initialize loading screen (hidden by default)
    this.createLoadingScreen();

    // Initialize UI components
    this.setupUI();
  }

  // Create a loading screen that can be shown when needed
  private createLoadingScreen(): void {
    // Create container for loading screen
    this.loadingScreen = new Rectangle("loadingScreen");
    this.loadingScreen.width = "100%";
    this.loadingScreen.height = "100%";
    this.loadingScreen.background = "rgba(0, 0, 0, 0.7)";
    this.loadingScreen.isVisible = false;
    this.editorUI.addControl(this.loadingScreen);

    // Add loading text
    this.loadingText = new TextBlock("loadingText", "Loading...");
    this.loadingText.color = "white";
    this.loadingText.fontSize = 24;
    this.loadingText.fontWeight = "bold";
    this.loadingScreen.addControl(this.loadingText);
  }

  // Method to initialize and get the editor UI
  public getEditorUI(): AdvancedDynamicTexture {
    return this.editorUI;
  }

  // Show loading screen
  public displayLoadingUI(message: string = "Loading..."): void {
    if (this.loadingScreen) {
      this.loadingText.text = message;
      this.loadingScreen.isVisible = true;
    }
  }

  // Hide loading screen
  public hideLoadingUI(): void {
    if (this.loadingScreen) {
      this.loadingScreen.isVisible = false;
    }
  }

  private setupUI(): void {
    this.createBackButton();
    this.createEditorTitle();
    this.createSnapToGridToggle();
    this.createSaveLoadPanel();
  }

  private createBackButton(): void {
    const backButton = UIComponentsFactory.createButton(
      "backButton",
      "Back to Menu"
    );
    backButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    backButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    backButton.left = "20px";
    backButton.top = "20px";
    backButton.zIndex = 100;
    backButton.hoverCursor = "pointer";
    backButton.onPointerClickObservable.add(() => {
      console.log("Back to Menu clicked");
      this.events.onBackToMenu();
    });

    this.editorUI.addControl(backButton);
  }

  private createEditorTitle(): void {
    const editorTitle = new TextBlock("editorTitle", "Fuzzelton Level Creator");
    editorTitle.color = "white";
    editorTitle.fontSize = 22;
    editorTitle.height = "30px";
    editorTitle.fontWeight = "bold";
    editorTitle.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    editorTitle.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    // editorTitle.top = "5px";
    this.editorUI.addControl(editorTitle);
  }

  private createSnapToGridToggle(): void {
    // Container for the grid toggle
    const gridContainer = new Rectangle("gridToggleContainer");
    gridContainer.width = "180px";
    gridContainer.height = "40px";
    gridContainer.background = UIComponentsFactory.BG_PANEL_COLOR;
    gridContainer.cornerRadius = UIComponentsFactory.DEFAULT_CORNER_RADIUS;
    gridContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;
    gridContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    gridContainer.top = "-20px";
    gridContainer.left = "-20px";
    this.editorUI.addControl(gridContainer);

    // Create the checkbox
    this.snapToggleBtn = new Checkbox("snapToGridToggle");
    this.snapToggleBtn.width = "20px";
    this.snapToggleBtn.height = "20px";
    this.snapToggleBtn.color = "orange";
    this.snapToggleBtn.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    this.snapToggleBtn.left = "10px";
    this.snapToggleBtn.zIndex = 100;
    gridContainer.addControl(this.snapToggleBtn);

    // Label for checkbox
    const toggleLabel = new TextBlock("gridToggleLabel", "Snap to Grid");
    toggleLabel.color = "white";
    toggleLabel.fontSize = 16;
    toggleLabel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    toggleLabel.left = "10px";
    gridContainer.addControl(toggleLabel);

    // event to toggle grid visibility and snapping
    this.snapToggleBtn.onIsCheckedChangedObservable.add((isChecked) => {
      // console.log("DEBUG toggle changed to ", isChecked);
      this.events.onGridToggle(isChecked);
    });
  }

  private createSaveLoadPanel(): void {
    // We create container for save/test/load buttons
    const sceneManagmentPanel = new Rectangle("saveLoadPanel");
    sceneManagmentPanel.width = "250px";
    sceneManagmentPanel.height = "150px";
    sceneManagmentPanel.background = UIComponentsFactory.BG_PANEL_COLOR;
    sceneManagmentPanel.cornerRadius =
      UIComponentsFactory.DEFAULT_CORNER_RADIUS;
    sceneManagmentPanel.horizontalAlignment =
      Control.HORIZONTAL_ALIGNMENT_CENTER;
    sceneManagmentPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
    sceneManagmentPanel.top = "-20px";
    this.editorUI.addControl(sceneManagmentPanel);
    this.saveLoadPanel = sceneManagmentPanel;

    // Stack panel for buttons
    const stackPanel = new StackPanel("saveLoadStack");
    stackPanel.width = "100%";
    stackPanel.hoverCursor = "cursor"; // we set default cursor on stack panel
    sceneManagmentPanel.addControl(stackPanel);

    // Title
    const title = new TextBlock("saveLoadTitle", "Scene Management");
    title.color = "white";
    title.fontSize = 18;
    title.height = "30px";
    title.fontWeight = "bold";
    stackPanel.addControl(title);

    // Save button
    const saveButton = UIComponentsFactory.createButton(
      "saveButton",
      "Save Scene",
      {
        width: "200px",
        height: "30px",
        color: "white",
        background: "green",
      }
    );
    saveButton.onPointerClickObservable.add(() => this.events.onSaveScene());
    stackPanel.addControl(saveButton);

    // Spacing
    stackPanel.addControl(UIComponentsFactory.createSpacing(5));

    // Load button
    const loadButton = UIComponentsFactory.createButton(
      "loadButton",
      "Load Scene",
      {
        width: "200px",
        height: "30px",
        color: "white",
        background: "blue",
      }
    );
    loadButton.onPointerClickObservable.add(() => this.events.onLoadScene());
    stackPanel.addControl(loadButton);

    // Spacing
    stackPanel.addControl(UIComponentsFactory.createSpacing(5));

    // Test levle button
    const testButton = UIComponentsFactory.createButton(
      "testButton",
      "Test Level",
      {
        width: "200px",
        height: "30px",
        color: "white",
        background: "orange",
      }
    );
    testButton.onPointerClickObservable.add(async () => {
      await this.events.onTestLevel();
    });
    stackPanel.addControl(testButton);
  }

  public createModelSidebar(modelFiles: string[]): void {
    // Create sidebar panel
    const sidebar = UIComponentsFactory.createSidebar("modelSidebar", {
      alignment: Control.HORIZONTAL_ALIGNMENT_LEFT,
    });
    this.editorUI.addControl(sidebar);
    this.modelSidebar = sidebar;

    // Create scrollable panel for models
    const scrollViewer = UIComponentsFactory.createScrollViewer("modelScroll");
    sidebar.addControl(scrollViewer);

    // Create stack panel for model items
    const stackPanel = new StackPanel("modelPanel");
    stackPanel.width = "100%";
    // stackPanel.paddingLeft = "5%";
    // stackPanel.paddingRight = "5%";
    stackPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    stackPanel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;

    scrollViewer.addControl(stackPanel);

    // Title for the sidebar
    const sidebarTitle = new TextBlock("modelSidebarTitle", "Available Models");
    sidebarTitle.color = "white";
    sidebarTitle.fontSize = 20;
    sidebarTitle.height = "40px";
    sidebarTitle.fontWeight = "bold";
    sidebarTitle.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    sidebarTitle.paddingTop = "10px";
    sidebarTitle.paddingBottom = "10px";
    stackPanel.addControl(sidebarTitle);

    // Add each model to the sidebar
    for (const filename of modelFiles) {
      const modelId =
        this.assetManager.getModelIdFromFilename(filename) || filename;

      // Determine color based on model name
      let color = "gray";
      if (modelId.includes("Blue")) color = "blue";
      else if (modelId.includes("Red")) color = "red";
      else if (modelId.includes("Yellow")) color = "yellow";

      // Get preview image URL
      const fileInfo = modelFiles.find((file) =>
        file.toLowerCase().includes(modelId.toLowerCase())
      );

      let previewImageUrl = "";
      if (fileInfo) {
        const baseFilename = fileInfo.split(".")[0];
        previewImageUrl = `/kaykit/previews/ImageToStl.com_${baseFilename}.gltf.png`;
      }

      const modelItem: MeshItem = {
        id: `model-${modelId}`,
        modelId,
        type: "model",
        label: this.formatModelName(modelId).slice(0, 18) + " ...", // we limit label length to 22 chars
        color,
        imageUrl: previewImageUrl,
      };

      this.addModelItemToSidebar(stackPanel, modelItem);
      stackPanel.addControl(UIComponentsFactory.createSpacing(5));
    }
  }

  private formatModelName(modelId: string): string {
    return modelId
      .replace(/([a-z])([A-Z])/g, "$1 $2") // Insert space between camelCase
      .replace(/_/g, " ") // Replace underscores with spaces
      .replace(/team/i, "Team ") // Add space after "team"
      .split(" ")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");
  }

  private addModelItemToSidebar(parent: Container, item: MeshItem): void {
    const itemContainer = new Rectangle(`${item.id}-container`);
    itemContainer.width = "100%";
    itemContainer.height = "70px";
    itemContainer.thickness = 1;
    itemContainer.color = "lightgray";
    itemContainer.background = "rgba(70, 70, 70, 0.9)";
    itemContainer.cornerRadius = UIComponentsFactory.DEFAULT_CORNER_RADIUS;
    itemContainer.paddingBottom = "5px";
    itemContainer.paddingLeft = "10px";
    itemContainer.paddingRight = "10px";
    itemContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
    itemContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
    itemContainer.isPointerBlocker = true;
    itemContainer.hoverCursor = "grab";
    parent.addControl(itemContainer);

    const alignmentImg = 10;
    const imgSize = 40;
    // Create the image preview with fallback
    const preview = UIComponentsFactory.createImagePreview(
      `${item.id}-preview`,
      item.imageUrl || "",
      {
        width: imgSize + "px",
        height: imgSize + "px",
        left: 10 + "px",
        fallbackColor: item.color,
      }
    );
    itemContainer.addControl(preview);

    // Label for the model
    const modelLabel = new TextBlock(`${item.id}-label`, item.label);
    modelLabel.color = "white";
    modelLabel.fontSize = 12;
    modelLabel.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    modelLabel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    modelLabel.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;
    // modelLabel.top = "5px";
    modelLabel.left = imgSize + alignmentImg * 2 + "px";
    itemContainer.addControl(modelLabel);

    // Make the item draggable
    itemContainer.onPointerDownObservable.add(() => {
      if (item.type === "model" && item.modelId) {
        this.events.onModelSelected(item.modelId);
      }
    });
  }

  public getSceneName(): string {
    return this.sceneName;
  }

  public setSceneName(name: string): void {
    this.sceneName = name;
  }

  public promptForSceneName(): string | null {
    return prompt("Enter a name for your scene:", this.sceneName);
  }

  public dispose(): void {
    // dispose of the editor UI
    if (this.editorUI) {
      this.editorUI.dispose();
    }

    // dispose of the loading screen
    if (this.loadingScreen) {
      this.loadingScreen.dispose();
    }

    // Dispose of the model sidebar
    if (this.modelSidebar) {
      this.modelSidebar.dispose();
    }

    // Clear event handlers
    this.events = {} as UIEvents;

    // Clear references to avoid memory leaks
    this.scene = null as any;
    this.ground = null as any;
    this.gridMesh = null;
  }
}
