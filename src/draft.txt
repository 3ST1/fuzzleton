// import * as BABYLON from "@babylonjs/core";
// import "@babylonjs/core/Debug/debugLayer";
// import "@babylonjs/inspector";
// import "@babylonjs/loaders/glTF";
// import HavokPluginModule from "@babylonjs/havok"; // Changed import for clarity
// import { GameEnvironment } from "./GameEnvironnement";
// import { AdvancedDynamicTexture, Button, Control } from "@babylonjs/gui";
// import PlayerController from "./player/thirdPersonController";
// import { Level } from "./level/Level";
// import MainMenu from "./MainMenu";
// import LevelCreator from "./levelCreator/levelCreator";
// import { initializeAssetsManager } from "./basicAssetManager";
// import {
//   SceneSerializer,
//   SerializedScene,
// } from "./levelCreator/SceneSerializer";

// export enum GameState {
//   MENU = 0,
//   PLAY = 1,
//   LEVEL_CREATOR = 2,
//   TEST_LEVEL = 3,
// }

// export const GRAVITY = 9.81;

// class App {
//   private canvas!: HTMLCanvasElement;
//   private engine!: BABYLON.Engine;
//   public scene: BABYLON.Scene | null = null; // Made public for easier access if needed, ensure it's managed
//   public gameState: GameState = GameState.MENU;
//   private assetsManager!: BABYLON.AssetsManager;

//   private currentLevelTestData: string | null = null;
//   private levelCreatorInstance: LevelCreator | null = null;
//   public appInstance!: App;

//   havokPlugin: any; // Keep as any if HavokPluginModule is complex to type here
//   physicsPlugin: any; // BABYLON.HavokPlugin
//   physicsViewer: any; // BABYLON.PhysicsViewer
//   char: PlayerController | null = null;

//   constructor(canvasId: string) {
//     this.appInstance = this;
//     this.initialize(canvasId);
//     window.addEventListener("resize", () => {
//       this.engine.resize();
//     });

//     window.addEventListener("keydown", (ev) => {
//       if (ev.key === "i" || ev.key === "I") {
//         if (this.scene?.debugLayer.isVisible()) {
//           this.scene.debugLayer.hide();
//         } else {
//           this.scene?.debugLayer.show();
//         }
//       }
//     });
//   }

//   private async loadHavokPlugin(): Promise<void> {
//     try {
//       const HavokPhysics = await HavokPluginModule(); // Use the resolved module
//       this.havokPlugin = HavokPhysics;
//       this.physicsPlugin = new BABYLON.HavokPlugin(true, this.havokPlugin);
//       // PhysicsViewer is now part of core, no need to await physicsPlugin specifically
//       this.physicsViewer = new BABYLON.PhysicsViewer();
//       console.log("Havok Plugin loaded and PhysicsViewer initialized.");
//     } catch (error) {
//       console.error("Failed to load Havok Plugin:", error);
//     }
//   }

//   private async initialize(canvasId: string) {
//     await this.loadHavokPlugin();
//     this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
//     this.engine = new BABYLON.Engine(this.canvas, true);
//     this.displayMainMenu();
//   }

//   private displayMainMenu(): void {
//     this.engine.stopRenderLoop(); // Stop any previous render loop
//     this.scene?.dispose(); // Dispose any existing scene
//     this.scene = null;

//     this.gameState = GameState.MENU;
//     this.currentLevelTestData = null;

//     // Create a new scene for the main menu
//     this.scene = new BABYLON.Scene(this.engine); // MainMenu will use this scene or create its own

//     const mainMenu = new MainMenu(
//       this.canvas,
//       this.engine,
//       // this.scene, // Pass the scene to MainMenu if it expects it
//       async () => await this.startGame(),
//       async () => await this.startLevelCreator()
//     );
//     // If MainMenu creates its own scene, App.this.scene might need to be updated by MainMenu
//     // For simplicity, assuming MainMenu uses the scene passed or App.this.scene becomes the menu's scene.
//     // If MainMenu manages its own scene and render loop:
//     // mainMenu.render() might call engine.runRenderLoop.
//     // If App.ts manages the loop for menu:
//     this.engine.runRenderLoop(() => {
//       if (mainMenu.menuScene && !mainMenu.menuScene.isDisposed()) {
//         // Check if menuScene exists and is not disposed
//         mainMenu.menuScene.render();
//       } else if (this.scene && this.gameState === GameState.MENU) {
//         // Fallback if menuScene is managed differently
//         this.scene.render();
//       }
//     });
//   }

//   private async startGame(isTesting: boolean = false): Promise<void> {
//     this.engine.stopRenderLoop();
//     // Don't dispose sceneToPreserve (LevelCreator's scene)
//     // Dispose current App.scene ONLY if it's not the one we intend to preserve (i.e., LevelCreator's scene)
//     if (
//       this.scene &&
//       (!this.levelCreatorInstance ||
//         this.scene !== this.levelCreatorInstance.lvlCreatorScene)
//     ) {
//       console.log("startGame: Disposing current scene:", this.scene.uid);
//       this.scene.dispose();
//     }
//     this.scene = null; // Important: Nullify before creating new one

//     this.gameState = isTesting ? GameState.TEST_LEVEL : GameState.PLAY;
//     console.log(`startGame: Set gameState to ${this.gameState}`);

//     this.scene = await this.createGameScene();
//     console.log("startGame: New game scene created:", this.scene.uid);

//     this.engine.runRenderLoop(() => {
//       if (this.scene && !this.scene.isDisposed) {
//         this.scene.render();
//       }
//     });
//   }

//   public async startTestLevel(
//     levelDataJSON: string,
//     creatorInstance: LevelCreator // Expect the actual instance
//   ): Promise<void> {
//     console.log("startTestLevel: Received request to test level.");
//     this.currentLevelTestData = levelDataJSON;
//     this.levelCreatorInstance = creatorInstance; // Store the active creator instance

//     // Stop the LevelCreator's render loop. Its scene is preserved.
//     console.log("startTestLevel: Stopping LevelCreator's render loop.");
//     this.engine.stopRenderLoop();
//     // App.this.scene currently refers to the LevelCreator's scene. We will change it in startGame.

//     await this.startGame(true);
//   }

//   private async startLevelCreator(): Promise<void> {
//     console.log(
//       `startLevelCreator: Current gameState: ${this.gameState}, App.scene: ${this.scene?.uid}`
//     );
//     this.engine.stopRenderLoop();

//     // If there's an active game/test scene, dispose it.
//     // The LevelCreator's scene (if it exists and App.scene points to it) should NOT be disposed here.
//     if (
//       this.scene &&
//       (!this.levelCreatorInstance ||
//         this.scene !== this.levelCreatorInstance.lvlCreatorScene)
//     ) {
//       console.log(
//         "startLevelCreator: Disposing non-creator scene:",
//         this.scene.uid
//       );
//       this.scene.dispose();
//       this.scene = null;
//     }

//     this.currentLevelTestData = null;
//     this.gameState = GameState.LEVEL_CREATOR;

//     if (!this.levelCreatorInstance || this.levelCreatorInstance.isDisposed()) {
//       // Check if instance itself is "disposed"
//       console.log(
//         "startLevelCreator: No valid LevelCreator instance. Creating new one."
//       );
//       if (this.levelCreatorInstance)
//         this.levelCreatorInstance.disposeLevelCreatorResources(); // Clean up if partially exists
//       this.levelCreatorInstance = new LevelCreator(
//         this.canvas,
//         this.engine,
//         this,
//         async () => {
//           // This is the "Back to Main Menu" callback from LevelCreator's UI
//           console.log("LevelCreator's 'Back to Menu' button clicked.");
//           if (!confirm("Exit to Main Menu? Unsaved changes will be lost."))
//             return;

//           this.engine.stopRenderLoop();
//           this.levelCreatorInstance?.disposeLevelCreatorResources(); // Creator disposes its own scene
//           this.levelCreatorInstance = null;
//           this.scene = null; // App's scene reference is cleared
//           await this.displayMainMenu(); // Go to main menu
//         }
//       );
//       this.scene = this.levelCreatorInstance.lvlCreatorScene; // App now tracks creator's scene
//       this.levelCreatorInstance.render(); // LevelCreator starts its own render loop
//     } else {
//       console.log(
//         "startLevelCreator: Restoring existing LevelCreator instance."
//       );
//       // The LevelCreator instance and its scene (lvlCreatorScene) are assumed to be valid.
//       this.scene = this.levelCreatorInstance.lvlCreatorScene; // Point App's scene to the creator's

//       // Ensure UI is ready for interaction if returning
//       // this.levelCreatorInstance.reattachUIAndEvents();

//       // The engine's render loop was stopped. Restart it for the creator's scene.
//       this.levelCreatorInstance.render(); // This calls engine.runRenderLoop for lvlCreatorScene
//       console.log(
//         "startLevelCreator: Restarted render loop for existing LevelCreator's scene:",
//         this.scene.uid
//       );
//     }
//   }

//   private async createGameScene(): Promise<BABYLON.Scene> {
//     console.log("createGameScene: Creating new scene for game/test.");
//     const gameScene = new BABYLON.Scene(this.engine); // Create a fresh scene
//     this.assetsManager = initializeAssetsManager(gameScene, this.engine);
//     this._setupPhysics(gameScene); // Enable physics for this new scene

//     const environment = new GameEnvironment(gameScene, this.canvas);
//     const thirdPers = true;
//     environment.setupGameEnvironment(thirdPers);

//     this.char = new PlayerController(gameScene, environment, thirdPers);

//     let levelDataForLoading: SerializedScene | null = null;
//     if (this.gameState === GameState.TEST_LEVEL && this.currentLevelTestData) {
//       try {
//         levelDataForLoading = await SceneSerializer.parseSerializedScene(
//           this.currentLevelTestData
//         );
//         console.log(
//           "createGameScene: Parsed test level data:",
//           levelDataForLoading
//         );
//       } catch (e) {
//         console.error("createGameScene: Error parsing test level data:", e);
//       }
//     }

//     const level = new Level(
//       gameScene,
//       environment,
//       this.assetsManager,
//       this.char,
//       levelDataForLoading
//     );

//     this.createButton(gameScene, environment, this.char, level); // Pass gameScene for UI
//     await level.initLevel(this.assetsManager);

//     this.canvas.style.opacity = "1";

//     gameScene.onBeforeRenderObservable.add(() => {
//       environment.updateFps(this.engine.getFps());
//       if (this.char) {
//         // Check if char exists
//         this.char.updatePlayer(gameScene.deltaTime);
//       }
//     });
//     gameScene.onBeforeAnimationsObservable.add(() => {
//       this.char?.onBeforeAnimations(); // Check if char exists
//     });
//     console.log(
//       "createGameScene: Finished creating game scene:",
//       gameScene.uid
//     );
//     return gameScene;
//   }

//   createButton(
//     uiScene: BABYLON.Scene, // Pass the scene the UI should attach to
//     env: GameEnvironment,
//     char: PlayerController,
//     level: Level
//   ) {
//     const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(
//       "GameUI",
//       true,
//       uiScene // Attach UI to the specified scene
//     );

//     const playButton = Button.CreateSimpleButton("btn", "Play (press P)");
//     playButton.width = "200px";
//     playButton.height = "50px";
//     playButton.color = "white";
//     playButton.background = "orange";
//     playButton.cornerRadius = 10;
//     playButton.fontSize = 20;
//     playButton.isVisible = this.gameState !== GameState.TEST_LEVEL; // Hide if just testing

//     let backButtonText = "Menu";
//     let backButtonAction = async () => {
//       console.log("GameUI: 'Menu' button clicked.");
//       // engine.stopRenderLoop and scene.dispose will be handled by displayMainMenu
//       await this.displayMainMenu();
//     };

//     if (this.gameState === GameState.TEST_LEVEL) {
//       backButtonText = "Back to Creator";
//       backButtonAction = async () => {
//         console.log("GameUI: 'Back to Creator' button clicked.");
//         // engine.stopRenderLoop and scene.dispose for game scene
//         // will be handled by startLevelCreator
//         await this.startLevelCreator();
//       };
//     }

//     const backBtn = Button.CreateSimpleButton("backBtn", backButtonText);
//     // ... (styling for backBtn)
//     backBtn.width = "150px";
//     backBtn.height = "40px";
//     backBtn.color = "white";
//     backBtn.background = "orange";
//     backBtn.cornerRadius = 5;
//     backBtn.fontSize = 16;
//     backBtn.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
//     backBtn.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;
//     backBtn.left = "20px";
//     backBtn.top = "20px";
//     backBtn.onPointerClickObservable.add(backButtonAction);
//     advancedTexture.addControl(backBtn);

//     const pKeyListener = (event: KeyboardEvent) => {
//       if (
//         event.key.toLowerCase() === "p" &&
//         this.gameState !== GameState.TEST_LEVEL
//       ) {
//         window.removeEventListener("keydown", pKeyListener);
//         playButton.isVisible = false;
//         char.wakeUpPlayer();
//         level.generateRandomObjects(100);
//       }
//     };
//     if (this.gameState !== GameState.TEST_LEVEL) {
//       // Only add P listener if not testing
//       window.addEventListener("keydown", pKeyListener);
//     }

//     playButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;
//     playButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;
//     playButton.onPointerClickObservable.add(() => {
//       if (this.gameState !== GameState.TEST_LEVEL) {
//         window.removeEventListener("keydown", pKeyListener);
//         playButton.isVisible = false;
//         if (char) {
//           char.wakeUpPlayer();
//           level.generateRandomObjects(100);
//         }
//       }
//     });
//     advancedTexture.addControl(playButton);

//     if (this.gameState === GameState.TEST_LEVEL && char) {
//       console.log("GameUI: In TEST_LEVEL, waking up player automatically.");
//       char.wakeUpPlayer();
//       // Optionally: level.generateRandomObjects(0); // if test levels shouldn't have random objects
//     }
//   }

//   private _setupPhysics(scene: BABYLON.Scene) {
//     if (!this.physicsPlugin) {
//       console.error("Physics plugin not initialized...");
//       return; // Don't throw, just log and potentially skip physics
//     }
//     console.log("Physics plugin initialized: ", this.physicsPlugin);
//     scene.enablePhysics(
//       new BABYLON.Vector3(0, -GRAVITY, 0),
//       this.physicsPlugin
//     );
//     const physicsEngine = scene.getPhysicsEngine();
//     if (physicsEngine) {
//       physicsEngine.setTimeStep(1 / 60);
//     }
//     console.log("Physics enabled for scene: ", scene.uid);
//   }
// }

// // getLinearDamping and addPhysicsAggregate remain the same

export function addPhysicsAggregate(
  scene: BABYLON.Scene,
  meshe: BABYLON.TransformNode,
  shape: BABYLON.PhysicsShapeType,
  mass: number = 0,
  friction: number = 0.5,
  restitution: number = 0
): BABYLON.PhysicsAggregate {
  const physicsAggregate = new BABYLON.PhysicsAggregate(
    meshe,
    shape,
    { mass: mass, friction: friction, restitution: restitution },
    scene
  );

  // Set linear damping based on mass and friction
  // physicsAggregate.body.setLinearDamping(getLinearDamping(mass, friction));

  // Store it inside the mesh for later use (accessible through metadata)
  meshe.metadata = { physicsAggregate };

  return physicsAggregate;
}

// export default App;
